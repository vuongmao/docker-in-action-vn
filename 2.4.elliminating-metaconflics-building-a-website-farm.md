# Loại bỏ hàng loạt xung đột: Xây dựng một website farm

Trong phần cuối bạn đã nhìn thấy như thế nào DOCKER giúp bạn tránh xung đột phần mềm với process isolation. Nhưng nếu bạn không cẩn thận, bạn có thể xây dựng hệ thống với nhiều conflicts, hay những conflics giữa container bên trong DOCKER layer.

Xem xét một ví dụ khác nơi mà một client đã hỏi bạn xây dựng một hệ thống nơi mà bạn có thể host một số lượng biến của website cho khách hàng của họ. Họ cũng thích sử dụng công nghệ monitoring (giám sát) cái mà bạn đã xây dựng dễ dàng trong chương này. Đơn giản bằng việc mở rộng hệ thống bạn đã xây dựng trước đó sẽ là cách đơn giản nhất để hoàn thành công việc này mà không chỉnh sửa cấu hình cho NGINX. Trong ví dụ này bạn sẽ xây dựng một hệ thống với nhiều container chạy web server và một monitoring agent (agent) cho mỗi web seerver. Hệ thống sẽ trong giống như mô tả kiến trúc trong hình 2.2

![](https://github.com/vuongmao/docker-in-action-vn/blob/master/asset/2.4-image-1.png)

Hình 2.2 Một nhóm các web server container và quan hệ với những monitoring agents.

## 2.4.1 Xác định container một cách linh hoạt

Cách tốt nhất để tìm nguyên nhân tại việc tạo ra nhiềm bản copy một các đơn giản của NGINX container mà bạn đã sử dụng trong ví dụ cuối là một ý tưởng tệ để thử nghiệm cho chính bạn:

```
docker run -d --name webid nginx <-- Create a container named "webid"
docker run -d --name webid nginx <-- Create another container named "webid"
```

Command thứ 2 ở đây sẽ xảy ra lỗi với một conflict error:

```
FATA[0000] Error response from daemon: Conflict. The name "webid" is
already in use by container 2b5958ba6a00. You have to delete (or rename)
that container to be able to reuse that name.
```

Sử dụng tên container cố định giống như _web_ rất hữu ích cho thử nghiệm và tài liệu, nhưng trong một hệ thống với nhiều container, sử dụng tên cố định giống như vậy có thể tạo ra conflics. Vì mặc định DOCKER gán một tên duy nhất (human-friendly) cho mỗi container nó tạo. `--name` flag chỉ đơn giản là ghi lại process với một giá trị đã biết. Khi tình huống xuất hiện ở đây tên của một container cần thay đổi, bạn có thể thay đổi tên container với `docker rename` command:

```
docker rename webid webid-old    <-- Rename the current web container to "webid-old"
docker run -d --name webid nginx <-- Create another container named "webid"
```

Thay đổi tên containers có thê giúp giảm bớt conflict tên nhưng nó không làm được gì để tránh vấn đề từ lần đầu tiên. Ngoài names, DOCKER gán một định danh duy nhất đã được để cập trong ví dụ đầu tiên. Nhưng số hex-encode 1024-bit và trong nó giống như vầy

```
7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
```

Khi những container được start trong chế độ detached, định danh của chúng sẽ được in ra ngoài terminal. Bạn có thể sử dụng những định dạnh này thay cho tên container với bấy cứ command nào cần chỉ định một container cụ thể. Ví dụ, bạn có thể sử dụng ID trước đó với một `stop` hay `exec` command:

```
docker exec \
    7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5 \
ps

docker stop \
    7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
```

Xác suất cao về tính duy nhất của IDs được tạo ra nghĩa là nó khó xảy ra xung đột với ID này. Ở mức độ thất hơn, nó cũng khó xảy ra xung đột với 12 ký tự đầu tiên của ID này trên cùng một máy tính. Vậy trong hầu hết các giao diện DOCKER, bạn sẽ nhìn thấy những container ID bị cắt ngắn thành 12 ký tự đầu tiên. Điều này đã tạo ra IDs trông thân thiện với người dùng hơn. Bạn có thể sử dụng chúng bất cứ ở đâu khi được yêu cầu một container identifier. Vì vậy ở 2 commands trước có thể được viết giống như vầy:

```
docker exec 7cb5d2b9a7ea ps
docker stop 7cb5d2b9a7ea
``` 

Cả hai ID này đều phù hơp cho người dùng. Nhưng chúng làm việc tốt với script và kỹ thuật tự động. DOCKER có một vài ý nghĩa của việc có được container ID để làm tự động hóa. Trong những trường hợp đầy đủ hay đã bị cắt đi số ID sẽ được sử dụng. 

Cách đầu tiên để có được số ID của một container để đơn giản hóa start hay create một container mới và gán kết quả của command đến một biến SHELL. Như bạn đã nhìn thấy từ trước, khi một container mới được start trong chế độ _detached_, contaiter ID được ghi ra terminal (stdout). Bạn **KHÔNG THỂ** sử dụng điều này với interactive container nếu đây là cách duy nhất để có được container ID tại thời điểm tạo. May mắn thay bạn có thể sử dụng command khác để tạo một container mà không starting nó. `docker create` command rất giống với `docker run` sự khác nhau ở đây là container được tạo trong trạng thái 'stopped'.

```
docker create nginx
```

Kết quả sẽ giống như dòng này:

```
b26a631e536d3caae348e9fd36e7661254a11511eb2274fb55f9f7c788721b0d
```

Nếu bạn đang sử dụng Linux command shell như sh hay bash, bạn có thể đơn giản gán kết quả đến biến shell và sử dụng nó cho lần sau:

```
CID=$(docker create nginx:latest)  <-- This will work on POSIX compliant shells
echo $CID
```

Những biến Shell tạo một cơ hội mới cho xung đột, nhưng phạm vi của xung đột được giới hạn trong mỗi terminal session hay môi trường processing hện tại khi script đã được launched. Những xung đột này có thể tránh được dễ dàng bởi sử dụng một lần hay chương trình được quản lý bở môi trường. Vấn đề với cách tiếp cận này sẽ không giúp được nếu nhiều người dùng hay những nhiều process tự động cần chia sẽ thông tin. Trong những trường hợp này bạn có thể sử dụng một container ID (CID) file.

Cả `docker run` và `docker create` command cung cấp flag khác nhau để viết ID của một container đến một file đã biết:

```
docker create --cidfile /tmp/web.cid nginx <-- Create a new stopped container
cat /tmp/web.cid                           <-- Inspect the file
```

Giống như sử dụng biến shell, đây là tính năng làm tăng cơ hội cho sự xung đột. Tên của CID file (đã được cung cấp phía sau `--cidfile`) phải được biết hay có vài cấu trức được biết. Cũng chỉ giống như tên container đặt thủ công, cách tiếp cận này sử dung tên đã biết ở namespace toàn cục (Docker-wide). Tin tốt là DOCKER sẽ không tạo một container mới đang sử dụng CID đã được cung cấp nếu đó là file đã tồn tại. Command sẽ thất bạn như khi bạn tạo 2 container cùng tên.

Một lý do để sử dụng những CID file thay vì tên của container là những CID file có thể được chia sẻ với nhiều container một cách dễ dàng và thay đổi tên cho những container đó. Cái này sử dụng một tính năng DOCKER gọi là **volume*, cái này được đề cập trong chương 4.

TIP - Một chiến lượng để đối phó với xung đột CID file-naming phân vùng (partition) namespace bằng cách sử dụng quy ước đường dẫn đã biết hay dự đoán có thể. Ví dụ, trong kịch bản này bạn có thể sử dụng một đường dẫn chứa tất cả các web container dưới một thư mục đã biết và phân vùng thư mục đó bằng customer ID. Đây sẽ là kết quả trong một đường dẫn **/containers/web/customer1/web.cid** hay **/contain- ers/web/customer8/web.cid**.
