# Loại bỏ hàng loạt xung đột: Xây dựng một website farm

Trong phần cuối bạn đã nhìn thấy như thế nào DOCKER giúp bạn tránh xung đột phần mềm với process isolation. Nhưng nếu bạn không cẩn thận, bạn có thể xây dựng hệ thống với nhiều conflicts, hay những conflics giữa container bên trong DOCKER layer.

Xem xét một ví dụ khác nơi mà một client đã hỏi bạn xây dựng một hệ thống nơi mà bạn có thể host một số lượng biến của website cho khách hàng của họ. Họ cũng thích sử dụng công nghệ monitoring (giám sát) cái mà bạn đã xây dựng dễ dàng trong chương này. Đơn giản bằng việc mở rộng hệ thống bạn đã xây dựng trước đó sẽ là cách đơn giản nhất để hoàn thành công việc này mà không chỉnh sửa cấu hình cho NGINX. Trong ví dụ này bạn sẽ xây dựng một hệ thống với nhiều container chạy web server và một monitoring agent (agent) cho mỗi web seerver. Hệ thống sẽ trong giống như mô tả kiến trúc trong hình 2.2

![](https://github.com/vuongmao/docker-in-action-vn/blob/master/asset/2.4-image-1.png)

Hình 2.2 Một nhóm các web server container và quan hệ với những monitoring agents.

## 2.4.1 Xác định container một cách linh hoạt

Cách tốt nhất để tìm nguyên nhân tại việc tạo ra nhiềm bản copy một các đơn giản của NGINX container mà bạn đã sử dụng trong ví dụ cuối là một ý tưởng tệ để thử nghiệm cho chính bạn:

```
docker run -d --name webid nginx <-- Create a container named "webid"
docker run -d --name webid nginx <-- Create another container named "webid"
```

Command thứ 2 ở đây sẽ xảy ra lỗi với một conflict error:

```
FATA[0000] Error response from daemon: Conflict. The name "webid" is
already in use by container 2b5958ba6a00. You have to delete (or rename)
that container to be able to reuse that name.
```

Sử dụng tên container cố định giống như _web_ rất hữu ích cho thử nghiệm và tài liệu, nhưng trong một hệ thống với nhiều container, sử dụng tên cố định giống như vậy có thể tạo ra conflics. Vì mặc định DOCKER gán một tên duy nhất (human-friendly) cho mỗi container nó tạo. `--name` flag chỉ đơn giản là ghi lại process với một giá trị đã biết. Khi tình huống xuất hiện ở đây tên của một container cần thay đổi, bạn có thể thay đổi tên container với `docker rename` command:

```
docker rename webid webid-old    <-- Rename the current web container to "webid-old"
docker run -d --name webid nginx <-- Create another container named "webid"
```

Thay đổi tên containers có thê giúp giảm bớt conflict tên nhưng nó không làm được gì để tránh vấn đề từ lần đầu tiên. Ngoài names, DOCKER gán một định danh duy nhất đã được để cập trong ví dụ đầu tiên. Nhưng số hex-encode 1024-bit và trong nó giống như vầy

```
7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
```

Khi những container được start trong chế độ detached, định danh của chúng sẽ được in ra ngoài terminal. Bạn có thể sử dụng những định dạnh này thay cho tên container với bấy cứ command nào cần chỉ định một container cụ thể. Ví dụ, bạn có thể sử dụng ID trước đó với một `stop` hay `exec` command:

```
docker exec \
    7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5 \
ps

docker stop \
    7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
```

Xác suất cao về tính duy nhất của IDs được tạo ra nghĩa là nó khó xảy ra xung đột với ID này. Ở mức độ thất hơn, nó cũng khó xảy ra xung đột với 12 ký tự đầu tiên của ID này trên cùng một máy tính. Vậy trong hầu hết các giao diện DOCKER, bạn sẽ nhìn thấy những container ID bị cắt ngắn thành 12 ký tự đầu tiên. Điều này đã tạo ra IDs trông thân thiện với người dùng hơn. Bạn có thể sử dụng chúng bất cứ ở đâu khi được yêu cầu một container identifier. Vì vậy ở 2 commands trước có thể được viết giống như vầy:

```
docker exec 7cb5d2b9a7ea ps
docker stop 7cb5d2b9a7ea
``` 

Cả hai ID này đều phù hơp cho người dùng. Nhưng chúng làm việc tốt với script và kỹ thuật tự động. DOCKER có một vài ý nghĩa của việc có được container ID để làm tự động hóa. Trong những trường hợp đầy đủ hay đã bị cắt đi số ID sẽ được sử dụng. 

Cách đầu tiên để có được số ID của một container để đơn giản hóa start hay create một container mới và gán kết quả của command đến một biến SHELL. Như bạn đã nhìn thấy từ trước, khi một container mới được start trong chế độ _detached_, contaiter ID được ghi ra terminal (stdout). Bạn **KHÔNG THỂ** sử dụng điều này với interactive container nếu đây là cách duy nhất để có được container ID tại thời điểm tạo. May mắn thay bạn có thể sử dụng command khác để tạo một container mà không starting nó. `docker create` command rất giống với `docker run` sự khác nhau ở đây là container được tạo trong trạng thái 'stopped'.

```
docker create nginx
```

Kết quả sẽ giống như dòng này:

```
b26a631e536d3caae348e9fd36e7661254a11511eb2274fb55f9f7c788721b0d
```

Nếu bạn đang sử dụng Linux command shell như sh hay bash, bạn có thể đơn giản gán kết quả đến biến shell và sử dụng nó cho lần sau:

```
CID=$(docker create nginx:latest)  <-- This will work on POSIX compliant shells
echo $CID
```

Những biến Shell tạo một cơ hội mới cho xung đột, nhưng phạm vi của xung đột được giới hạn trong mỗi terminal session hay môi trường processing hện tại khi script đã được launched. Những xung đột này có thể tránh được dễ dàng bởi sử dụng một lần hay chương trình được quản lý bở môi trường. Vấn đề với cách tiếp cận này sẽ không giúp được nếu nhiều người dùng hay những nhiều process tự động cần chia sẽ thông tin. Trong những trường hợp này bạn có thể sử dụng một container ID (CID) file.

Cả `docker run` và `docker create` command cung cấp flag khác nhau để viết ID của một container đến một file đã biết:

```
docker create --cidfile /tmp/web.cid nginx <-- Create a new stopped container
cat /tmp/web.cid                           <-- Inspect the file
```

Giống như sử dụng biến shell, đây là tính năng làm tăng cơ hội cho sự xung đột. Tên của CID file (đã được cung cấp phía sau `--cidfile`) phải được biết hay có vài cấu trức được biết. Cũng chỉ giống như tên container đặt thủ công, cách tiếp cận này sử dung tên đã biết ở namespace toàn cục (Docker-wide). Tin tốt là DOCKER sẽ không tạo một container mới đang sử dụng CID đã được cung cấp nếu đó là file đã tồn tại. Command sẽ thất bạn như khi bạn tạo 2 container cùng tên.

Một lý do để sử dụng những CID file thay vì tên của container là những CID file có thể được chia sẻ với nhiều container một cách dễ dàng và thay đổi tên cho những container đó. Cái này sử dụng một tính năng DOCKER gọi là **volume*, cái này được đề cập trong chương 4.

TIP - Một chiến lượng để đối phó với xung đột CID file-naming phân vùng (partition) namespace bằng cách sử dụng quy ước đường dẫn đã biết hay dự đoán có thể. Ví dụ, trong kịch bản này bạn có thể sử dụng một đường dẫn chứa tất cả các web container dưới một thư mục đã biết và phân vùng thư mục đó bằng customer ID. Đây sẽ là kết quả trong một đường dẫn **/containers/web/customer1/web.cid** hay **/contain- ers/web/customer8/web.cid**.

Trong nhiều trường hợp khác, bạn có thể sử dụng command như `docker ps` để lấy ID của container. Ví dụ, nếu bạn muốn lấy ID đã được cắt của container được tạo cuối cùng, bạn có thể sử dụng cái này:

```
CID=$(docker ps --latest --quiet) <-- This will work on POSIX- compliant shells
echo $CID

CID=$(docker ps -l –q)            <-- Run again with the short-form flags
echo $CID
```

TIP - Nếu bạn muốn lấy đầy đủ container ID, bạn có thể sử dụng lựa chọn --no-trunc tại `docker ps` command

Những trường hợp tự động được đề cập bằng những tính mà bạn thấy cho đến nay. Nhưng ngay cả rút gọn ID giúp đỡ, những container ID hiếm khi dễ dàng đọc hay ghi nhớ. Vì lý do nay, DOCKER cũng tạo ra tên dễ đọc cho người dùng cho mỗi container.

Quy tước tên sử dụng một tính từ cá nhân, và last name của một nhà khoa học có tính ảnh hưởng, nhà kỹ sữ, nhà phát minh, hay nhà lãnh đạo tư tưởng khác. Ví dụ tên được tạo ra là compassionate_swawrtz, hungry_goodall, và distracted_turing. Những thứ đó dường như để chạm đến sự ngọt ngào cho khả năng đọc và nhớ. Khi bạn làm việc với DOCKER một cách trực tiếp, bạn có thể luôn sử dụng `docker ps` để tìm kiếm nhữn tên thân thiện.

Xác định containner có thể gặp khó khăn, nhưng bạn có thể quản lý vấn đề này bằng các sử dụng ID và tính năng tạo tên của DOCKER.

## 2.4.2 Trạng thái container và sự phụ thuộc

Với kiến thức mới, hệ thống mới có thể trông giống như thế này:

```
MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)  <-- Make sure mailer from first example is running
WEB_CID=$(docker create nginx)


AGENT_CID=$(docker create --link $WEB_CID:insideweb \
    --link $MAILER_CID:insidemailer \
    dockerinaction/ch2_agent)
```

Trích đoạn này có thể được sử dụng để tạo để tạo một script mới để lunches một NGINX mới và khởi tạo agent cho mỗi khách hàng của bạn. Bạn có thể sử dụng `docker ps` để nhìn thấy rằng chúng đã được tạo ra:

```
docker ps
```

Lý do cả NGINX và agent đã được thêm vào output phải làm với trạng thái container. DOCKER containers sẽ có một trong 4 trạng thái và sự chuyển tiếp thông qua command theo sợ đồ trong hình 2.3.

Cả hai container mới bạn đã start xuất hiện trong danh sách của container bởi vì `docker ps` chỉ thể hiện những container đang chạy như mặc định. Những container này đã được tạo ra cách đặc biệt với `docker create` và chưa bao giờ được start (trạng thái exited). Để nhìn thấy tất cả containers (Bao gồm những container ở trạng thái exited), sử dụng lựa chọn `-a`:

```
docker ps -a
```

![](https://github.com/vuongmao/docker-in-action-vn/blob/master/asset/2.4.2-image-1.png)

Hình 2.3 - Sơ đồ trạng thái chuyển đổi của DOCKER container được báo cáo tại cột status

Bây giờ bạn đã xác minh cả hai containers đã được tạo, bạn cần start chúng. Bạn có thể sử dụng `docker start` command:

```
docker start $AGENT_CID
docker start $WEB_CID
```

Chạy những command này sẽ có kết quả lỗi. Những container cần được start theo thứ tự ngược lại của chuỗi phụ thuộc chúng. Bởi vì bạn đã cố start agent container trước web container, DOCKER bác một lỗi như thế này:

```
Error response from daemon: Cannot start container
03e65e3c6ee34e714665a8dc4e33fb19257d11402b151380ed4c0a5e38779d0a: Cannot link to a non running container: /clever_wright AS /modest_hopper/ insideweb
FATA[0000] Error: failed to start one or more containers
```

Trong ví dụ này, Agent container có một phụ thuộc trên web container. Bạn cần start web container trước:

```
docker start $WEB_CID
docker start $AGENT_CID
```

Điều này mang ý nghĩa là khi bạn xem xét các cơ chế công việc. Cơ chế liên kết thêm IP addresses vào trong containers phụ thuộc, và những containers không chạy thì không có IP address. Nếu bạn cố start một container có một sự phụ thuộc vào một container không chạy, DOCKER sẽ không có IP address để thêm vào. Liên kết container được để cập trong chương 5, nhưng nó có ích để ví dụ cho điểm quan trong này để start container.

Cho dù bạn sử dụng `docker run` hay `docker create`, kết quả những container cần là start theo thứ tự ngược lại của chuỗi phụ thuộc. Điều này có nghĩa là không thể xây dựng các phụ thuộc vòng tròn bằng cách sử dụng mối quan hệ DOCKER container.

Tại điểm này bạn có thể đặt mọi thứ với nhau trong một script súc tích trông giống như sau:

```
MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)

WEB_CID=$(docker run -d nginx)

AGENT_CID=$(docker run -d \
    --link $WEB_CID:insideweb \
    --link $MAILER_CID:insidemailer \
    dockerinaction/ch2_agent)
```

Bây giờ bạn đã tự tin để script này có thể chạy mà không có ngoại lệ mỗi lần khách hàng của bạn cần cung cấp một site mới. Khách hàng của bạn đã trở lại và cám ơn bạn cho trang web và monitoring bạn đã hoàn thành. Nhưng mọi thứ đã thay đổi.

Họ đã quyết định tập trung xây dựng websites của họ với WordPress (Một mã nguồn mở phổ biến cho quản lý nội dung và blog). May mắn thay, wordpress được xuất bản thông qua DOCKER Hub trong một repository có thên là wordpress:4. Tất cả cái bạn cần để vận hành là một nhóm các commands để cung cấp một website Wordpress mới, có mornitoring và tính năng arlert tương tự cái bạn đã cung cấp.

Điều thú vị về hệ thống quản lý nội dung và những hệ thống trạng thái khác là data, chúng làm việc bằng cách chạy một chương trình đặc biết. Blog Wordpess của Adam khác với Blog Wordpress Betty, ngay cả việc nếu họ chạy cùng một phần mềm. Chỉ có nội dung là khác nhau, ngay cả nếu nội dung giống nhau, chúng vẫn khác nhau bởi vì chúng chạy trên những site khác nhau.

Nếu bạn xây dựng hệ thống hay phần mềm, cần biết quá nhiều về môi trường của họ - như là address hay locations cố định của những dịch vụ phụ thuộc - Nó khó để thay đổi môi trường hay tái sử dụng phần mềm. Bạn cần cung cấp một hết thống với sự phụ thuộc mội trường tối thiểu trước khi hợp đồn được hoàn thành.
